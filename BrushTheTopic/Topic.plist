<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB3</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>什么是runTime， 他可以用来做什么？项目中的运用。</string>
		<key>topicAnswer</key>
		<string>• 什么是runtime
OC的函数调用称为消息发送。属于动态调用过程。在编译期并不能决定真正调用哪个函数，只有在运行的时候才会根据函数的名称找到对应的函数来调用。
说到runtime就离不开
消息发送机制
1.对象调用一个方法就是向这个对象发送一条消息。首先通过对象的isa指针去找对象所对应的class，然后在class的cache中通过该SEL查找对应函数method,如果cache里面未找到，就去methodList里面去找。如果还找不到就去superClassMethodList里面去找，如果找到了，就放进cache里面，方便下次使用。 如果还是找不到，runtime不会立即报错。而是开始给对象几次补救的机会。
1. 动态方法解析：向当前类发送resolveInstanceMethod信号,询问当前对象有没有动态添加这个方法
2. 向当前对象发送 forwardingTragetSelector信号 询问当前对象，有没有别的对象可以处理这个消息。
3. 如果上面两个方法都没有做处理，将会进行消息转发：runtime发送methodSignatrueSelector消息获取selector对应的方法签名，如果返回非空就调用forwrrdInvocation消息转发，如果返回空，就会向对象发送doesNotRecognizeSelector 程序崩溃退出
4. 如果本类中没有的方法就去父类里面去找，父类里面没有就去其他类里面去找，如果找到了就返回这个对象，让其执行，这样就实现了消息转发。
• 他可以用来做什么
1.动态给系统类添加方法和变量
2.替换系统的方法实现
3.防crash（具体方案需要仔细看）
3.归档接档（例如第三方model生成库）
4.json转model（具体实现需要看第三方库）</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string></string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>什么是runLoop？他可以用来做什么？项目中需要注意的地方。</string>
		<key>topicAnswer</key>
		<string>runLoop顾名思义，是一种循环，但是他不像do while一样，会使CPU进入忙等状态，RunLoop在没有任务的时候会进入休眠状态，有任务的时候再唤醒去处理对应的任务。
RunLoop是一个对象，它包含多个mode，多个commonMode和一个正在运行的mode。
RunLoop和线程是绑定在一起的。每个线程都有一个对应的RunLoop对象，我们可以获取他，但是我们不能直接创建RunLoop。
RunLoop和线程是一一对应的，对应的方式是以key--value的方式存储在一个全局的数据字典表里。
主线程的RunLoop在初始化字典表的时候创建好
子线程的RunLoop在首次被调用的时候创建，如果不调用那就一直不会被创建、
RunLoop会在 线程销毁掉之后自动销毁。
项目中的运用
Timer
一个timer被加入到RunLoop中的时候，RunLoop会为重复的时间点添加事件。例如10：10， 10：20，但是RunLoop为了节约资源并不会在非常准确的时间点调用这个Timer。NSTimer有个属性叫做Tolerance（宽容度），标记了到了当前时间点之后，允许的最大误差值。由于NTimer这种机制，所以他必须依赖于RunLoop才能执行。
如果这个时间点错过了他只能等待下一个时间点。就像公交车，玩手机错过了这一班车，就只能等下一班车。
为了避免这个问题。可以使用GCD Timer，因为GCD的Timer所在线程如果没有RunLoop，GCD会临时创建一个线程起执行这个block，执行完再销毁掉。

AutoreleasePool
ARC下的产物，为了替代人工管理内存，大大简化了iOS开发人员的内存管理工作；实际是系统代替人工在合适的地方添加release、autoRelease等内存释放操作。
RunLoop和AutoreleasePool的关系。创建RunLoop时会创建一个AutoreleasePool，RunLoop进入休眠时会销毁掉AutoreleasePool并创建一个新的AutoreleasePool。RunLoop被销毁时，AutoreleasePool也会被销毁。

ScrollView
在scrollView滑动的时候会使NSTimer无效。有两种解决方法。
（1.吧NSTimer放进runLoop并设置mode为common
（2.使用GCD Timer
实现常驻线程</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB1</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>远程推送流程</string>
		<key>topicAnswer</key>
		<string>1.App注册APNs
（a.只要注册过的设备才能接受到消息,在UIApplication的registerUserNotificationSettings:方法注册
（b.注册之前有两个必要条件必须准备好：开发配置文件，应用程序的bundle indentifier应和配置文件的App Id一致。
2.App获取device Token
（a.在 DidRegisterForRemoteNotificationWithDeviceToken中获取device Token 此方法发生在注册之后。
（b.如果获取失败需要在didFailToRegisterForRemoteNotificationWithError 中查看错误信息，此方法发生在获取device Token失败之后
（c.只能在真机上获取device Token
3.App 发送 device Token 给应用程序服务商，告诉服务器当前设备允许接收消息
（a.device Token生产算法只有apple掌握。所以为了避免算法发生变化收不到推送，所以每次启动App都要获取device Token。
（b.通常可以通过一个网络请求，吧device Token发送给应程序服务商的服务器端。在这个过程中最好只上传一次，一旦发现device Token发生变化 最后将旧的deviceToken一起上送给服务器端。服务器端删除旧令牌，存入新令牌，防止发送无效消息。

4.应用程序服务商收到App device Token 组织信息发送给APNs。
5.APNs根据消息中的 device Token 查找已注册的设备 发送消息。
（a.正常情况下可以根据device Token可以成功吧消息发送到客户端，但是也不排除客户端被卸载的情况，如果发生错误，APNs会将这个错误信息通知服务端，防止浪费资源。（服务端收到这错误信息会把这个device Token移除  下次不再发送。）</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB2</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>什么是KVC?他可以用来做什么?底层原理?</string>
		<key>topicAnswer</key>
		<string>(Key-value coding）键值编码
KVC应用场景，通常用来修改类的属性，或者字典转模型
KVC，通过字符串的方式访问属性，
当一个对象的属性调用setValue方法时，会现在对象的内部查找对应的setKey方法，如果没有找到，就查找与key同名且带有下划线的属性，如果还没有找到，就查找key同名的属性并赋值。
如果到这里还没有找到， 就调用setValueForUndefindeKey和 setValue：forUndefindeKey 方法。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB4</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>什么是KVO?,底层原理?</string>
		<key>topicAnswer</key>
		<string>(Key Value Observing, 键值观察)
KVO的本质就是重写被观察属性的setter方法。 
当一个类的属性被观察，系统会通过runTime为这个类添加一个派生类。并把这个类的isa指针指向这个派生类，这样就实现了给被观察属性赋予新值是，调用的是派生类的set方法。重写的set方法在值改变的前后 (willChangeValueForKey didChangeValueForKey),通知观察对象，值的变化。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB5</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>Thread,GCD,Operation</string>
		<key>topicAnswer</key>
		<string>• Thread是封装程度最小最轻量级，使用更灵活，但是需要手动管理线程的生命周期、线程同步和线程加锁等，开销比较大。
• GCD（Grand Central Dispatch），又叫做大中央调度，对线程操作进行了封装，加入了新特性，内部进行了效率优化，提供简洁的C语言接口，使用更加简洁高效，也是苹果推荐的方法。
GCD的优点
GCD会自动利用更多的CPU内核
GCD可用于多核的并行运算
GCD会自动管理线程的生命周期
程序员只需要告诉GCD执行什么任务，不需要编写任何线程管理代码。
有两个比较重要的概念队列和任务
（1：队列
	◦ 串行：FIFO的方式执行队列中的任务
	◦ 并行：队列中的先后添加的任务可以同时并行执行，任务之间不会相互等待，而且这些任务执行过程中的执行顺序不可预知。
（2：任务
	◦ 同步：dispatch_sync,同步会阻塞当前线程，要等添加的耗时任务块block完成后，函数才能回返，后面的代码块才能继续执行。如果在主线程，则会发生阻塞，用户感觉应用不响应，这是开发中所要避免的。有时使用同步任务的的原因，是想保证任务的执行顺序。
	◦ 异步：dispatch_async，异步指的是将任务添加到队列之后函数立马返回，后面的代码不用等待添加的任务完成返回即可继续执行。
• NSOperation, NSOperation是基于GCD的一个抽象基类，将线程封装成要执行的操作，不需要管理线程的同步和生命周期，比GCD更可控，例如可以加入操作依赖、设置操作队列最大可并发执行的操作个数、取消操作等。NSOperation作为抽象基类不具备封装我们操作的功能，需要他的两个实体子类，NSBlockOperation、NSInvocationOperatiom,或者继承NSOperation自定义子类。
什么时候使用GCD什么时候使用NSOperation？
如果任务有相互依赖关系，顺序性，就使用NSOperation
如果需要多好的并发的能力就是使用GCD，当让我们平常简单任务处理也是使用GCD。
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB6</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>MVVM</string>
		<key>topicAnswer</key>
		<string>MVVM 这个模式的核心是VM层，这是个特殊的model类型。用来程序的UI状态。他包含描述每个UI状态的属性。比如文本输入域的当前文本，或者某个按钮是否可用，他同时暴露了视图可以执行哪些行为，例如按钮点击或手势。
M数据模型层 model层用来存放服务器返回的JSON转成的model数据
V视图展示层 主要指View和ViewController View可以直接拥有ViewModel
VM 视图适配器，他暴露出的属性和View元素显示内容，或者元素状态一一对应。ViewModel可以拥有Model
Binder还有一个比较重要的binder，虽然MVVM单词中没有他的一席之地，但是binder是MVVM的灵魂。他的最主要作用是在View和ViewModel中间做了双向数据绑定。

MVC缺点：Massive View Controller，也就是胖VC。
MVVM缺点：1.学习成本高。2.DEBUG困难。
MVVM优点：
1.低耦合。View层可以独立于Model进行变化和修改，同时一个VIewmodel可以绑定到多个View/VC上
2.可重用性，可以吧一些视图逻辑放进ViewModel层里，让很多View/VC进行重用
3.独立开发，通过MVVM开发人员可以专注逻辑开发在ViewModel里面。而设计开发，开一专注于界面设计
4.可测试，通常来说要进行界面测试比较困难，但是MVVM课对ViewModel进行测试</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB7</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string></string>
		<key>topicAnswer</key>
		<string></string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB8</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string></string>
		<key>topicAnswer</key>
		<string></string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB9</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string></string>
		<key>topicAnswer</key>
		<string></string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB10</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>weak的自己实现</string>
		<key>topicAnswer</key>
		<string>1，建个全局的映射表;定义为弱引用表
  2，表的结构是哈希表；
  3，表的key是对象的地址内存地址
  4，表的value是指向该对象的所有弱引用的指针；
  5，当前对象的引用计数为0的时候查询到弱引用表里的对象内存地址，遍历其中指向该对象的所有指针，将其置为nil;</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB11</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>__block的自己实现</string>
		<key>topicAnswer</key>
		<string>1,__block是内部是一个对象 {iSA，forwarding指针，当前对象}
  2，block的截获变量是劫持局部变量，局部静态变量是劫持不了的，全局的也劫持不了；
  3，我们可以参考局部静态变量截获不了的原因是因为访问的是局部变量的指针，所以对象的值改变，指针对应的也会改变，那么我们可以设计一个结构体包括当前对象和一个指向当前对象的指针，我们让block内部截获该结构体的指针，那么改变对象的值后，指针指向的内存空间的值也会随之改变。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB12</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>一个接口被调用一万次的优化方案；</string>
		<key>topicAnswer</key>
		<string>1，系统为了加快查找效率，是利用了缓存，在缓存列表缓存该方法的地址。
   2，我们可以直接访问该方法的指针地址来加快查找效率。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB13</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>分类的方法覆盖原类方法如何不让覆盖而调用；</string>
		<key>topicAnswer</key>
		<string>1，遍历类方法列表，查找当前方法同名的所有实现，然后调用最后一个，就是原类方法

   2，Method * modethods = class_copyMethodList([self class],&amp;count);//u_int count;
     Sel name = method_getName(methods[i])
     If name == 想要的 index = I；
     Sel name = method_getName(methods[index])
     IMP imp = method_getImpImplementaion(methods[index])</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB14</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>swift的范型理解</string>
		<key>topicAnswer</key>
		<string>   1，泛型就是起个占位符作用，string,array,dictionay都是泛型；
   2，泛型函数，泛型类型，泛型约束，泛型协议。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB15</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>swift的option底层实现，</string>
		<key>topicAnswer</key>
		<string>   1，和三目运算符差不多，有值得时候就是值本身，无值的时候就是 nil 底层是枚举：case:none,some(Wrapped),关联值就是传进来的值；
   2,由于不知道是什么类型所以需要解包；
   3，解包方式：强制解包：！,nin就奔溃；2，妥协解包（if let a=option）3,空合运算符式解包：?? 给默认值；
   4，optional的链式调用；如：ob?.cls?.name?.uppercased()，果其中任何一个节点为 nil ，整个调用链都会失败，即返回 nil ，而不会crash
   5，隐身可选就是let height = &quot;&quot;</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB16</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>为什么使用swift，他比oc的优势</string>
		<key>topicAnswer</key>
		<string>1、Swift容易阅读，语法和文件结构简易化。
   2、Swift更易于维护，文件分离后结构更清晰。
   3、Swift更加安全，它是类型安全的语言。
   4、Swift代码更少，简洁的语法，可以省去大量冗余代码
   5、Swift速度更快，运算性能更高。
   访问权限由大到小依次为：open，public，internal（默认），fileprivate，private</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB17</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>swift Unowned与Weak的理解</string>
		<key>topicAnswer</key>
		<string>1,如果产生循环引用的两个属性都允许为nil,这种情况适合用弱引用来解决
	两个类中,相互引用的两个属性都为可选类型,那么可以在一个属性的前面添加****weak****关键字,使该变量变为弱引用.
   2,如果产生循环引用的两个属性一个允许为nil,另一个不允许为nil,这种情况适合用无主引用来解决
	只能在不能为nil的那个属性前面加unowned关键字,就是说unowned设置以后即使它原来引用的内容已经被释放了，它仍然会保持对被已经释放了的对象的一个 &quot;****无效的****&quot; 引用，它不能是 Optional 值，也不会被指向 nil****。如果尝试去调用这个引用的方法或者访问成员属性的话，程序就会崩溃.
   3,如果产生循环引用的两个属性都必须有值,不能为nil,这种情况适合一个类使用无主属性,另一个类使用隐式解析可选类型;
九，动态库和静态库的区别</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB21</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>动态库形式：.dylib和.framework
静态库形式：.a和.framework</string>
		<key>topicAnswer</key>
		<string>静态库：链接时，静态库会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝（图1所示）
系统动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存（图2所示）

十：常驻线程的实现：</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB22</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>常驻线程的实现：</string>
		<key>topicAnswer</key>
		<string> NSShread + runloop
NSShread + GCD的信号量</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB23</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>自旋锁和其他锁的区别</string>
		<key>topicAnswer</key>
		<string>锁用于解决线程争夺资源的问题，一般分为两种，自旋锁(spin)和互斥锁(mutex)。
互斥锁可以解释为线程获取锁，发现锁被占用，就向系统申请锁空闲时唤醒他并立刻休眠。互斥锁加锁的时候，等待锁的线程处于休眠状态，不会占用CPU的资源
自旋锁比较简单，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。自旋锁加锁的时候，等待锁的线程处于忙等状态，并且占用着CPU的资源。
原子操作的颗粒度最小，只限于读写，对于性能的要求很高，如果使用了互斥锁势必在切换线程上耗费大量资源。相比之下，由于读写操作耗时比较小，能够在一个时间片内完成，自旋更适合这个场景。

临界区：指的是一块对公共资源进行访问的代码，并非一种机制或是算法。

自旋锁（OSSpinLock，os_unfair_lock）：是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。

互斥锁（NSLock，@synchronized）：是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区而达成。

读写锁（pthread_rwlock，）：是计算机程序的并发控制的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁) 用于解决多线程对公共资源读写问题。读操作可并发重入，写操作是互斥的。 读写锁通常用互斥锁、条件变量、信号量实现。

信号量（semaphore）：是一种更高级的同步机制，互斥锁可以说是、semaphore在仅取值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。

条件锁：就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行。

递归锁（NSRecursiveLock，pthread_mutex）递归锁有一个特点，就是同一个线程可以加锁N次而不会引发死锁。
pthread_mutex锁也支持递归，只需要设置PTHREAD_MUTEX_RECURSIVE即可


OSSpinLock不在安全：

具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。

苹果工程师 Greg Parker 提到，对于这个问题，一种解决方案是用 truly unbounded backoff 算法，这能避免 livelock 问题，但如果系统负载高时，它仍有可能将高优先级的线程阻塞数十秒之久；另一种方案是使用 handoff lock 算法，这也是 libobjc 目前正在使用的。锁的持有者会把线程 ID 保存到锁内部，锁的等待者会临时贡献出它的优先级来避免优先级反转的问题。理论上这种模式会在比较复杂的多锁条件下产生问题，但实践上目前还一切都好。

os_unfair_lock 是苹果官方推荐的替换OSSpinLock的方案，但是它在iOS10.0以上的系统才可以调用。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB24</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>dispatch_once实现原理</string>
		<key>topicAnswer</key>
		<string>+ (instancetype)sharedInstance
{
    /*定义相应类实例的静态变量；
    意义：函数内定义静态变量，无论该函数被调用多少次，
         在内存中只初始化一次，并且能保存最后一次赋的值
    */
    static ClassName *instance = nil;
    /*定义一个dispatch_once_t(其实也就是整型)静态变量，
    意义：作为标识下面dispatch_once的block是否已执行过。
         static修饰会默认将其初始化为0，当值为0时才会执行block。
         当block执行完成，底层会将onceToken设置为1，这也就是为什
         么要传onceToken的地址（static修饰的变量可以通过地址修改
         onceToken的值），同时底层会加锁来保证这个方法是线程安全的
    */
    static dispatch_once_t onceToken;
    /*只要当onceToken == 0时才会执行block，否则直接返回静态变量instance*/
    dispatch_once(&amp;onceToken, ^{
        instance = [[ClassName alloc] init];
        //...
    });
    return instance;
}
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB25</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>常驻线程一般用在哪里</string>
		<key>topicAnswer</key>
		<string>这个需求场景其实很普遍：比方 界面的交互操作背后的一些列业务逻辑 都可以丢在常驻线程上去计算，避免页面的卡顿，减轻主线程的计算操作。
这时候需要设计任务队列模型，对于逻辑层的各种业务就有迹可循了，一个一个执行的嘛。不管你界面怎么交互的，我的逻辑层都是一个一个执行，而且可以对任务做一些额外的统一处理：失败自动重试，日至记录等等</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB26</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>class和struct的区别</string>
		<key>topicAnswer</key>
		<string>class是类，是应用类型，strut是结构体，是值类型。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB27</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>set独有的方法有哪些？</string>
		<key>topicAnswer</key>
		<string>定义一个set
Let setA : Set&lt;Int&gt; = [1,2,3,4,4];//{1,2,3,4}
Let setB : Set&lt;Int&gt; = [1,3,5]
取并集
Let setUnion= setA.union(setB)/{1,2,3,4,5}]
取交集
let setIntersect = setA.intersection(setB)// {1, 3}
// 取差集 A - B
let setRevers = setA.subtracting(setB) // {2, 4}
// 取对称差集, A XOR B = A - B | B - A
let setXor = setA.symmetricDifference(setB) //{2, 4, 5, 7, 9}
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB28</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>实现一个min函数，返回二个元素较小的数</string>
		<key>topicAnswer</key>
		<string>//该题重点,泛型的使用
Func myMin&lt;T:comparable&gt;(_ a:T,_ b:T) -&gt; T {
Return a&lt;b?a:b
}
myMin(1,2);</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB30</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>Map、filter、reduce的作用</string>
		<key>topicAnswer</key>
		<string>map用于映射，可以将一个列表转换为另一个列表
[1,2,3].map{“\($0)”}//数字数组装换为字符串数组
[“1”,”2”,”3”]
Filter 用于过滤，可以筛选出想要的元素
[1,2,3].filter{$0 % 2 == 0}//筛选偶数
reduce合并
[1,2,3].reduce(“”){$0 + “\($1)”}装换为字符串并拼接：“123”
组合实例
(0 ..&lt; 10).filter{$0 % 2 == 0}.map{“\($0)”}.reduce(“”).{$0 + $1}//02468</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB31</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>什么是 copy on write时候</string>
		<key>topicAnswer</key>
		<string>写时复制，指的是swift中的值类型，并不会在一开始赋值的时候去复制，而是在修改的时候去复制。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB32</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>如何获取当前函数名和行号</string>
		<key>topicAnswer</key>
		<string>#file用于获取当前文件文件名
#line用于获取当前行号
#column用于获取当前列编号
#function用于获取当前函数名</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB33</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>guard使用场景</string>
		<key>topicAnswer</key>
		<string>guard和if类似，不同的是，guard总是有一个else语句，如果表达式是假或者值绑定失败的时候，会执行else语句，且在else语句中一定要停止函数调用。
常用使用场景为, 用户登录的时候, 验证用户是否有输入用户名密码等</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB34</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>defer使用场景</string>
		<key>topicAnswer</key>
		<string>defer语句块中的代码，会在当前作用域结束前调用，常用场景如异常退出后，关闭数据库连接。需要注意的是, 如果有多个 defer, 那么后加入的先执行</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB35</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>string和NSString的关系和区别</string>
		<key>topicAnswer</key>
		<string>NSString与String之间可以随意转换
String是结构体，值类型，NSString是类，引用类型。
通常，没必要使用NSString类，除非你要使用一些特有方法，例如使用pathExtension属性。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB36</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>如何截取string的某段你字符串</string>
		<key>topicAnswer</key>
		<string>swift 中, 有三个取子串函数,
substring:to，substring:from，substring:with</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB37</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>throws和rethrow的用法与作用</string>
		<key>topicAnswer</key>
		<string>throws用在函数上，表示这个函数会抛出错误。
有两种情况会抛出错误，一种是直接使用throw抛出，另一种是调用其他抛出异常的函数时，
rethrows与throws类似，不过只适用于参数中有函数，且函数会抛出异常的情况，rethrows可以用throws替换，反过来不行</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB38</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>Try?和 try!是什么意思</string>
		<key>topicAnswer</key>
		<string>这两个都用于处理可抛出异常的函数，使用这两个关键字可以不用写do catch。
区别在于try?在用于处理可抛出异常函数时，如果函数抛出异常，则返回nil，否则返回函数返回值的可选值，
而 try! 则在函数抛出异常的时候崩溃, 否则则返会函数返回值, 相当于(try? xxx)!</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB39</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>public和open的区别</string>
		<key>topicAnswer</key>
		<string>这两个都用于在模块中声明需要对外界暴露的函数，区别在于，public修饰的类，在模块外无法继承，而open则可以任意继承，公开度来说，public&lt;open。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB40</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>dynamic的作用</string>
		<key>topicAnswer</key>
		<string>由于swift是一个静态语言，所以没有Objective-C中的消息发送这些动态机制，dynamic的作用就是让swift 代码也能有 Objective-C 中的动态机制, 常用的地方就是 KVO 了, 如果要监控一个属性, 则必须要标记为 dynamic</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB41</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>如何解决引用循环</string>
		<key>topicAnswer</key>
		<string>1，转换为值类型，只有类会存在引用循环，所以如果能不用类，是可以解决引用循环的。
2、delegate使用weak属性。
3、闭包中，对有可能发生循环引用的对象，使用weak或者unowned修饰。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB42</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>定义静态方法时关键字static和class有什么区别</string>
		<key>topicAnswer</key>
		<string>static定义的方法不可以被子类继承,class则可以</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB43</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>main函数的autoreleasepool有什么作用</string>
		<key>topicAnswer</key>
		<string>autoreleasepool是自动释放池，加入自动释放池的对象，初始化时调用autorelease方法，那么在autoreleasepool语句块结束时，对象会被释放，从而防止占用过多内存，在ARC机制下，autorelease方法由系统自动调用。main函数中的autoreleasepool的作用，就是当主线程运行循环结束时，释放所有对象。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB44</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>Load、initialize详解与区别</string>
		<key>topicAnswer</key>
		<string>load实现原理
App启动，类第一次加载进内存的时候，会调用 + load 方法，无需导入，无需使用
每个类、分类的 + load 在程序运行过程中只会执行一次
+ load走的不是消息发送的 objc_msgSend 调用，而是找到 + load 函数的地址，直接调用
调用顺序
先调用宿主类的+ load函数
按照编译先后顺序调用（先编译，先调用）
调用子类的+load之前会先调用父类的+load
再调用分类的+ load函数
按照编译先后的顺序调用（先编译，先调用）
Initialize实现原理
类第一次接收到消息的时候，会调用该方法，需导入，并使用
+ Initialize走的是消息发送的objc_msgSend调用
initialize 与 load 的区别
load是类第一次加载的时候调用，initialize是类第一次接收到消息的时候调用，每个类只会initialize一次（当子类没有实现initialize方法时，会调用父类的initialize）方法
load 和 initialize，加载or调用的时候，都会先调用父类对应的 load or initialize 方法，再调用自己本身的;
load 和 initialize 都是系统自动调用的话，都只会调用一次
调用方式也不一样，load 是根据函数地址直接调用，initialize 是通过objc_msgSend
调用时刻，load是runtime加载类、分类的时候调用（只会调用一次）
调用顺序：
load：
先调用类的load
1)先编译的类，优先调用load
2)调用子类的load之前，会先调用父类的load（父类的load已经调用过了就不会再调用了）
再调用分类的load
initialize：
先初始化父类
再初始化子类（可能最终调用的是父类的初始化方法）
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB45</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>http的tcp和socket的tcp协议有什么不同</string>
		<key>topicAnswer</key>
		<string>HTTP的TCP协议是默认是短连接，TCP连接上，完成数据发送后即断开。Socket的TCP协议则是长连接，连接上后，只要不手动断开，则一直保持连接状态。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB46</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>.防护原理</string>
		<key>topicAnswer</key>
		<string>利用Objective-C语言的动态特性，采用AOP(Aspect Oriented Programming)面向切面编程的设计思想，在不侵入原有项目代码的基础之上，通过在 APP 运行时阶段对崩溃因素的的拦截和处理，使得 APP 能够持续稳定正常的运行。
   具象的说，就是对需要Hook的类添加Category（分类），在各个分类中通过Method Swizzling拦截容易造成崩溃的系统方法，将系统原有方法与添加的防护方法的selector（方法选择器）与IMP（函数实现指针）进行对调。然后在替换方法中添加防护操作，从而达到避免以及修复崩溃的目的。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB47</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>防护系统可以处理掉哪几种crash</string>
		<key>topicAnswer</key>
		<string>unrecognized selector（找不到对象方法或者类方法的实现）
KVO Crash
KVC Crash
NSNotification Crash
NSTimer Crash (注册了没有主动释放会内存泄露，甚至在定时任务触发时可能会导致crash)
Container / NSString Crash（集合类操作造成的崩溃，例如数组越界，插入 nil 等）
Threading Crash （非主线程刷新UI）</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB48</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>crash防护怎么做：</string>
		<key>topicAnswer</key>
		<string>具体步骤如下：
  1. 给NSObject添加一个分类，在分类中实现一个自定义的-crashKiller_forwardingTargetForSelector:方法；
 2. 利用Method Swizzling将-forwardingTargetForSelector:和 -crashKiller_forwardingTargetForSelector:进行方法交换。
   3. 在自定义的方法中，先判断当前对象是否已经实现了消息接受者重定向和消息重定向。如果都没有实现，就动态创建一个目标类，给目标类动态添加一个方法。
   4. 把消息转发给动态生成类的实例对象，由目标类动态创建的方法实现，这样 APP 就不会崩溃了。
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB49</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>NSDictionary 和 NSCache 区别：</string>
		<key>topicAnswer</key>
		<string>线程安全、LRU 缓存策略，还有的不会了
1.NSCache可以提供自动删减缓存功能，而且保证线程安全，与字典不同，不会拷贝键。
2.NSCache可以设置缓存上限，限制对象个数和总缓存开销。定义了删除缓存对象的时机。这个机制只对NSCache起到指导作用，不会一定执行。
3.NSPurgeableData搭配NSCache使用，可以自动清除数据。
4.只有那种“重新计算很费劲”的数据才值得放入缓存。
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB50</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>LRU 实现⽅法：双向链表 + 哈希表</string>
		<key>topicAnswer</key>
		<string>1，利用一个链表来实现，每次新插入数据的时候将新数据插到链表的头部；每次缓存命中（即数据被访问），则将数据移到链表头部；那么当链表满的时候，就将链表尾部的数据丢弃。

2，用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。

3，利用链表和hashmap。当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项
24.不使用中间变量改变ab的值
1
A = A + B 
B = A - B 
A = A - B 
2
A = A ^ B 
B = A ^ B 
A = A ^ B 

</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5_554BB7</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>nil、NIL、NSNULL有什么区别？</string>
		<key>topicAnswer</key>
		<string>nil和NIL可以说是等价的，都代表内存中的一块地址。
NSNULL代表一个指向nil的对象；</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5454BB7</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>如何实现一个线程安全的NSMutableArray?</string>
		<key>topicAnswer</key>
		<string>NSMutableArray是线程不安全的，当有多个线程同时对数组进行操作的时候看可能导致崩溃或者数据错误
线程锁：使用线程锁对数组读写时进行加锁。
派发队列：在《Effective Objective-C 2.0》书中第41条：多用派发队列，少用同步锁中指出：使用“使用串行同步队列”，将读取操作及写入操作都安排在同一个队列里，既可保证数据同步、而通过并发队列，结合GCD的栅栏块来不仅实现数据同步线程安全，还比串行同步队列方式更高效。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5444BB7</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>atomic修饰的属性是绝对安全的吗？为什么</string>
		<key>topicAnswer</key>
		<string>   不是，所谓的安全知识局限于Setter、Getter的访问器方法而言的，你对于它做Release的操作是不会受影响的，这个时候就容易崩溃了。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D4454BB7</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>实现 isEqual 和 hash 方法时要注意什么？</string>
		<key>topicAnswer</key>
		<string>  hash
对关键属性的hash值进行位或运算作为hash值
isEqual
==运算符判断是否是同一对象, 因为同一对象必然完全相同
判断是否是同一类型, 这样不仅可以提高判等的效率, 还可以避免隐式类型转换带来的潜在风险
判断对象是否是nil, 做参数有效性检查
各个属性分别使用默认判等方法进行判断
返回所有属性判等的与结果</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB51</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>id 和 instanceType 有什么区别？</string>
		<key>topicAnswer</key>
		<string>  相同点
instancetype 和 id 都是万能指针，指向对象。
不同点：
1.id 在编译的时候不能判断对象的真实类型，instancetype 在编译的时候可以判断对象的真实类型。
2.id 可以用来定义变量，可以作为返回值类型，可以作为形参类型；instancetype 只能作为返回值类型。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB52</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>self和super的区别</string>
		<key>topicAnswer</key>
		<string>self调用自己方法，super调用父类方法
self是类，super是预编译指令
[self class] 和 [super class] 输出是一样的
self和super底层实现原理
1.当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找，然后调用父类的这个方法
2.当使用 self 调用时，会使用 objc_msgSend 函数：
id objc_msgSend(id theReceiver, SEL theSelector, ...)
第一个参数是消息接收者，第二个参数是调用的具体类方法的 selector，后面是 selector 方法的可变参数。以 [self setName:] 为例，编译器会替换成调用 objc_msgSend 的函数调用，其中 theReceiver 是 self，theSelector 是 @selector(setName:)，这个 selector 是从当前 self 的 class 的方法列表开始找的 setName，当找到后把对应的 selector 传递过去。
3.当使用 super 调用时，会使用 objc_msgSendSuper 函数：
id objc_msgSendSuper(struct objc_super *super, SEL op, ...)
第一个参数是个objc_super的结构体，第二个参数还是类似上面的类方法的selector
struct objc_super {
	id receiver;
	Class superClass;
};

</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB53</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>@synthesize和@dynamic分别有什么作用？</string>
		<key>topicAnswer</key>
		<string>  @property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 	@synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。
@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB54</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>UIView 和 CALayer 是什么关系？</string>
		<key>topicAnswer</key>
		<string>UIView 继承 UI，而 UIResponder 是响应者对象，可以对iOS 中的事件响应及传递，CALayer 没有继承自 UIResponder，所以 CALayer 不具备响应处理事件的能力。CALayer 是 QuartzCore 中的类，是一个比较底层的用来绘制内容的类，用来绘制UI
UIView 是 CALayer 的代理，UIView 持有一个 CALayer 的属性，并且是该属性的代理，用来提供一些 CALayer 行的数据，例如动画和绘制。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB55</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>setNeedsDisplay和layoutIfNeeded两者是什么关系？</string>
		<key>topicAnswer</key>
		<string>   UIView的setNeedsDisplay和setNeedsLayout两个方法都是异步执行的。 ，如果有标记及立即刷新。
只有setNeedsLayout和layoutIfNeeded这两者合起来使用，才会立即重新刷新的效果。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB56</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>使用drawRect有什么影响？</string>
		<key>topicAnswer</key>
		<string> drawRect方法依赖Core Graphics框架来进行自定义的标注缺点：它处理touch事件时每次按钮被单击后，都会用setNeedsDisplay进行强制重绘；而且不止一次，每次单点事件触发重新执行。这样的话从性能的角度来说，对CPU和内存而言都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例，那就会很糟糕了。这个方法的调用机制也是非常特别。当您调用setNeedsDisplay方法时，UIKit将变为当前顶部标记为dirty，但还是会显示原始的内容，直到下一次的视图渲染周期，才会将标记为dirty的重新建立Core Graphics一部分，然后将使用内存中的数据恢复出来，再使用CGContextRef进行替换</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB57</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>深拷贝与浅拷贝</string>
		<key>topicAnswer</key>
		<string> 浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。
当对象中存在指针成员时，除了在复制对象时需要考虑自定义拷贝构造函数，还应该考虑以下两种情形：
当函数的参数为对象时，实参传递给形参的实际上是实参的一个拷贝对象，系统自动通过拷贝构造函数实现；
当函数的返回值为一个对象时，该对象实际上是函数内对象的一个拷贝，用于返回函数调用处。
copy方法:如果是非可扩展类对象，则是浅拷贝。如果是可扩展类对象，则是深拷贝。

mutableCopy方法:无论是可扩展类对象还是不可扩展类对象，都是深拷贝。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB58</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>简要说一下@autoreleasePool的数据结构？？</string>
		<key>topicAnswer</key>
		<string>简单说是双向链表，每张链表头尾相接，有 parent、child指针
每创建一个池子，会在首部创建一个 哨兵 对象,作为标记
最外层池子的顶端会有一个next指针。当链表容量满了，就会在链表的顶端，并指向下一张表。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB59</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>BAD_ACCESS在什么情况下出现？</string>
		<key>topicAnswer</key>
		<string>访问了悬垂指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。 死循环</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB60</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>iOS内存分区情况</string>
		<key>topicAnswer</key>
		<string>  栈区（Stack）
由编译器自动分配释放，存放函数的参数，局部变量的值等
栈是向低地址扩展的数据结构，是一块连续的内存区域
堆区（Heap）
由程序员分配释放
是向高地址扩展的数据结构，是不连续的内存区域
全局区
全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域
程序结束后由系统释放
常量区
常量字符串就是放在这里的
程序结束后由系统释放
代码区
存放函数体的二进制代码
注：
在 iOS 中，堆区的内存是应用程序共享的，堆中的内存分配是系统负责的
系统使用一个链表来维护所有已经分配的内存空间（系统仅仅记录，并不管理具体的内容）
变量使用结束后，需要释放内存，OC 中是判断引用计数是否为 0，如果是就说明没有任何变量使用该空间，那么系统将其回收
当一个 app 启动后，代码区、常量区、全局区大小就已经固定，因此指向这些区的指针不会产生崩溃性的错误。而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入弹出），所以当使用一个指针指向这个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃（也即是野指针报错）</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB61</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>如何手动触发KVO方法</string>
		<key>topicAnswer</key>
		<string>手动调用willChangeValueForKey和didChangeValueForKey方法
键值观察通知依赖于 NSObject 的两个方法: willChangeValueForKey: 和 didChangeValueForKey。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后， didChangeValueForKey 会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了 有人可能会问只调用didChangeValueForKey方法可以触发KVO方法，其实是不能的，因为willChangeValueForKey: 记录旧的值，如果不记录旧的值，那就没有改变一说了</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB62</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>为什么Block用copy关键字</string>
		<key>topicAnswer</key>
		<string>Block在没有使用外部变量时，内存存在全局区，然而，当Block在使用外部变量的时候，内存是存在于栈区，当Block copy之后，是存在堆区的。存在于栈区的特点是对象随时有可能被销毁，一旦销毁在调用的时候，就会造成系统的崩溃。所以Block要用copy关键字。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB63</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>解释一下 三次握手和四次挥手</string>
		<key>topicAnswer</key>
		<string>三次握手
1.由客户端向服务端发送 SYN 同步报文。
2.当服务端收到 SYN 同步报文之后，会返回给客户端 SYN 同步报文和 ACK 确认报文。
3.客户端会向服务端发送 ACK 确认报文，此时客户端和服务端的连接正式建立。
建立连接
1.这个时候客户端就可以通过 Http 请求报文，向服务端发送请求
2.服务端接收到客户端的请求之后，向客户端回复 Http 响应报文。
四次挥手
当客户端和服务端的连接想要断开的时候，要经历四次挥手的过程，步骤如下：
1.先由客户端向服务端发送 FIN 结束报文。
2.服务端会返回给客户端 ACK 确认报文 。此时，由客户端发起的断开连接已经完成。
3.服务端会发送给客户端 FIN 结束报文 和 ACK 确认报文。
4.客户端会返回 ACK 确认报文到服务端，至此，由服务端方向的断开连接已经完成。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB64</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>TCP 和 UDP的区别</string>
		<key>topicAnswer</key>
		<string>TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。
UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB65</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>Cookie和Session</string>
		<key>topicAnswer</key>
		<string> cookie
1.用户与服务器的交互
cookie主要是用来记录用户状态，区分用户，状态保存在客户端。cookie功能需要浏览器的支持。如果浏览器不支持cookie（如大部分手机中的浏览器）或者把cookie禁用了，cookie功能就会失效。
a).首次访问amazon时，客户端发送一个HTTP请求到服务器端 。服务器端发送一个HTTP响应到客户端，其中包含Set-Cookie头部
b).客户端发送一个HTTP请求到服务器端，其中包含Cookie头部。服务器端发送一个HTTP响应到客户端
c).隔段时间再去访问时，客户端会直接发包含Cookie头部的HTTP请求。服务器端发送一个HTTP响应到客户端
2.cookie的修改和删除
在修改cookie的时候，只需要新cookie覆盖旧cookie即可，在覆盖的时候，由于Cookie具有不可跨域名性，注意name、path、domain需与原cookie一致
删除cookie也一样，设置cookie的过期时间expires为过去的一个时间点，或者maxAge = 0(Cookie的有效期,单位为秒)即可
3、cookie的安全
事实上，cookie的使用存在争议，因为它被认为是对用户隐私的一种侵害，而且cookie并不安全
HTTP协议不仅是无状态的，而且是不安全的。使用HTTP协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。使用HTTP协议传输很机密的内容是一种隐患。

a).如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的secure属性为true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie。
b).此外，secure属性并不能对Cookie内容加密，因而不能保证绝对的安全性。如果需要高安全性，需要在程序中对Cookie内容加密、解密，以防泄密。
c).也可以设置cookie为HttpOnly，如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS（跨站脚本攻击）攻击
Session
Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，相应的也增加了服务器的存储压力。
Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。
Cookie 和Session 的区别：
1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
2、cookie相比session不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。
3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。
4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。而session存储在服务端，可以无限量存储
5、所以：将登录信息等重要信息存放为session;其他信息如果需要保留，可以放在cookie中
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB66</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>DNS是什么</string>
		<key>topicAnswer</key>
		<string> 因特网上的主机，可以使用多种方式标识，比如主机名或IP地址。一种标识方法就是用它的主机名（hostname），比如·www.baidu.com、www.google.com、gaia.cs.umass.edu等。这方式方便人们记忆和接受，但是这种长度不一、没有规律的字符串路由器并不方便处理。还有一种方式，就是直接使用定长的、有着清晰层次结构的IP地址，路由器比较热衷于这种方式。为了折衷这两种方式，我们需要一种能进行主机名到IP地址转换的目录服务。这就是域名系统（Domain Name System，DNS）的主要任务。
DNS是：
1、一个由分层的DNS服务器实现的分布式数据库
2、一个使得主机能够查询分布式数据库的应用层协议
DNS服务器通常是运行BIND软件的UNIX机器，DNS协议运行在UDP上，使用53号端口
DNS通常是由其他应用层协议所使用的，包括HTTP、SMTP等。其作用则是：将用户提供的主机名解析为IP地址
DNS的一种简单设计就是在因特网上只使用一个DNS服务器，该服务器包含所有的映射。很明显这种设计是有很大的问题的：
单点故障：如果该DNS服务器崩溃，全世界的网络随之瘫痪
通信容量：单个DNS服务器必须处理所有DNS查询
远距离的集中式数据库：单个DNS服务器必须面对所有用户，距离过远会有严重的时延。
维护：该数据库过于庞大，还需要对新添加的主机频繁更新。
所以，DNS被设计成了一个分布式、层次数据库
5、DNS解析过程
以www.163.com为例:
客户端打开浏览器，输入一个域名。比如输入www.163.com，这时，客户端会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。
查询www.163.com的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果。如果没有，本地DNS服务器还要向DNS根服务器进行查询。
根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。
本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。
最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB67</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>iOS开发中数据持有化性有哪几种</string>
		<key>topicAnswer</key>
		<string>iOS本地数据保存有多种方式,比如NSUserDefaults、归档、文件保存、数据库、CoreData、KeyChain(钥匙串)等多种方式。其中KeyChain(钥匙串)是保存到沙盒范围以外的地方，也就是与沙盒无关。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB68</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>多线程-&gt;进程和线程的关系</string>
		<key>topicAnswer</key>
		<string>1.线程是进程的执行单元，进程的所有任务都在线程中执行
2.线程是 CPU 分配资源和调度的最小单位
3.一个程序可以对应多个进程(多进程),一个进程中可有多个线程,但至少要有一条线程
4.同一个进程内的线程共享进程资源</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB69</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>什么是多线程</string>
		<key>topicAnswer</key>
		<string>多线程的实现原理：事实上，同一时间内单核的CPU只能执行一个线程，多线程是CPU快速的在多个线程之间进行切换（调度），造成了多个线程同时执行的假象。
如果是多核CPU就真的可以同时处理多个线程了。
多线程的目的是为了同步完成多项任务，通过提高系统的资源利用率来提高系统的效率。
优点:
能适当提高程序的执行效率
能适当提高资源利用率（CPU、内存利用率）
缺点:
开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能
线程越多，CPU在调度线程上的开销就越大
程序设计更加复杂：比如线程之间的通信、多线程的数据共享
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB70</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>多线程的并行和并发有什么区别</string>
		<key>topicAnswer</key>
		<string> 并行：充分利用计算机的多核，在多个线程上同步进行
并发：在一条线程上通过快速切换，让人感觉在同步进行</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB71</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>、iOS中实现多线程的几种方案，各自有什么特点？</string>
		<key>topicAnswer</key>
		<string>NSThread 面向对象的，需要程序员手动创建线程，但不需要手动销毁。子线程间通信很难。
GCD c语言，充分利用了设备的多核，自动管理线程生命周期。比NSOperation效率更高。
NSOperation 基于gcd封装，更加面向对象，比gcd多了一些功能。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB72</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>多个网络请求完成后执行下一步</string>
		<key>topicAnswer</key>
		<string>A、使用GCD的dispatch_group_t
创建一个dispatch_group_t
每次网络请求前先dispatch_group_enter,请求回调后再dispatch_group_leave，enter和leave必须配合使用，有几次enter就要有几次leave，否则group会一直存在。
当所有enter的block都leave后，会执行dispatch_group_notify的block。
NSString *str = @&quot;http://xxxx.com/&quot;;
NSURL *url = [NSURL URLWithString:str];
NSURLRequest *request = [NSURLRequest requestWithURL:url];
NSURLSession *session = [NSURLSession sharedSession];
dispatch_group_t downloadGroup = dispatch_group_create();
for (int i=0; i&lt;10; i++) {
    dispatch_group_enter(downloadGroup);
    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        NSLog(@&quot;%d---%d&quot;,i,i);
        dispatch_group_leave(downloadGroup);
    }];
    [task resume];
}

dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{
    NSLog(@&quot;end&quot;);
});
B、使用GCD的信号量dispatch_semaphore_t
dispatch_semaphore信号量为基于计数器的一种多线程同步机制。如果semaphore计数大于等于1，计数-1，返回，程序继续运行。如果计数为0，则等待。dispatch_semaphore_signal(semaphore)为计数+1操作,dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)为设置等待时间，这里设置的等待时间是一直等待。
创建semaphore为0，等待，等10个网络请求都完成了，dispatch_semaphore_signal(semaphore)为计数+1，然后计数-1返回
NSString *str = @&quot;http://xxxx.com/&quot;;
NSURL *url = [NSURL URLWithString:str];
NSURLRequest *request = [NSURLRequest requestWithURL:url];
NSURLSession *session = [NSURLSession sharedSession];
dispatch_semaphore_t sem = dispatch_semaphore_create(0);
for (int i=0; i&lt;10; i++) {
    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        NSLog(@&quot;%d---%d&quot;,i,i);
        count++;
        if (count==10) {
            dispatch_semaphore_signal(sem);
            count = 0;
        }
    }];
    [task resume];
}
dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@&quot;end&quot;);
});</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB73</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>多个网络请求顺序执行后执行下一步</string>
		<key>topicAnswer</key>
		<string>使用信号量semaphore
每一次遍历，都让其dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER)，这个时候线程会等待，阻塞当前线程，直到dispatch_semaphore_signal(sem)调用之后
NSString *str = @&quot;http://www.jianshu.com/p/6930f335adba&quot;;
NSURL *url = [NSURL URLWithString:str];
NSURLRequest *request = [NSURLRequest requestWithURL:url];
NSURLSession *session = [NSURLSession sharedSession];
dispatch_semaphore_t sem = dispatch_semaphore_create(0);
for (int i=0; i&lt;10; i++) {
    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        NSLog(@&quot;%d---%d&quot;,i,i);
        dispatch_semaphore_signal(sem);
    }];
    
    [task resume];
    dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
}

dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@&quot;end&quot;);
});</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB74</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>异步操作两组数据时, 执行完第一组之后, 才能执行第二组</string>
		<key>topicAnswer</key>
		<string>这里使用dispatch_barrier_async栅栏方法即可实现
dispatch_queue_t queue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);
dispatch_async(queue, ^{
    NSLog(@&quot;第一次任务的主线程为: %@&quot;, [NSThread currentThread]);
});
dispatch_async(queue, ^{
    NSLog(@&quot;第二次任务的主线程为: %@&quot;, [NSThread currentThread]);
});
bæriər
dispatch_barrier_async(queue, ^{
    NSLog(@&quot;第一次任务, 第二次任务执行完毕, 继续执行&quot;);
});

dispatch_async(queue, ^{
    NSLog(@&quot;第三次任务的主线程为: %@&quot;, [NSThread currentThread]);
});

dispatch_async(queue, ^{
    NSLog(@&quot;第四次任务的主线程为: %@&quot;, [NSThread currentThread]);
});
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB75</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>多线程中的死锁？</string>
		<key>topicAnswer</key>
		<string>死锁是由于多个线程（进程）在执行过程中，因为争夺资源而造成的互相等待现象，你可以理解为卡主了。产生死锁的必要条件有四个：
互斥条件 ： 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
请求和保持条件 ： 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
不可剥夺条件 ： 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
环路等待条件 ： 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
最常见的就是 同步函数 + 主队列 的组合，本质是队列阻塞。
dispatch_sync(dispatch_get_main_queue(), ^{
    NSLog(@&quot;2&quot;);
});
NSLog(@&quot;1&quot;)；

// 什么也不会打印，直接报错</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB76</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>GCD执行原理？</string>
		<key>topicAnswer</key>
		<string>GCD有一个底层线程池，这个池中存放的是一个个的线程。之所以称为“池”，很容易理解出这个“池”中的线程是可以重用的，当一段时间后这个线程没有被调用的话，这个线程就会被销毁。注意：开多少条线程是由底层线程池决定的（线程建议控制再3~5条），池是系统自动来维护，不需要我们程序员来维护（看到这句话是不是很开心？） 而我们程序员需要关心的是什么呢？我们只关心的是向队列中添加任务，队列调度即可。
如果队列中存放的是同步任务，则任务出队后，底层线程池中会提供一条线程供这个任务执行，任务执行完毕后这条线程再回到线程池。这样队列中的任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是同一条线程。
如果队列中存放的是异步的任务，（注意异步可以开线程），当任务出队后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务不需等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次提供一个线程供第二个任务执行，执行完毕后再回到底层线程池中。
这样就对线程完成一个复用，而不需要每一个任务执行都开启新的线程，也就从而节约的系统的开销，提高了效率。在iOS7.0的时候，使用GCD系统通常只能开5~8条线程，iOS8.0以后，系统可以开启很多条线程，但是实在开发应用中，建议开启线程条数：3~5条最为合理。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB77</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>数据安全及加密</string>
		<key>topicAnswer</key>
		<string>1、对称加密和非对称加密的区别
1、对称加密又称公开密钥加密，加密和解密都会用到同一个密钥，如果密钥被攻击者获得，此时加密就失去了意义。常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。
2、非对称加密又称共享密钥加密，使用一对非对称的密钥，一把叫做私有密钥，另一把叫做公有密钥；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法）。
2、简述 SSL 加密的过程用了哪些加密方法，为何这么作？
SSL 加密，在过程中实际使用了 对称加密 和 非对称加密 的结合。主要的考虑是先使用 非对称加密 进行连接，这样做是为了避免中间人攻击秘钥被劫持，但是 非对称加密 的效率比较低。所以一旦建立了安全的连接之后，就可以使用轻量的 对称加密。
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB81</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>isa指针的理解，对象的isa指针指向哪里？isa指针有哪两种类型？</string>
		<key>topicAnswer</key>
		<string>isa 等价于 is kind of
实例对象的 isa 指向类对象
类对象的 isa 指向元类对象
元类对象的 isa 指向元类的基类
isa 有两种类型
纯指针，指向内存地址
NON_POINTER_ISA，除了内存地址，还存有一些其他信息</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB78</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>Objective-C 如何实现多重继承？</string>
		<key>topicAnswer</key>
		<string>Object-c的类没有多继承,只支持单继承,如果要实现多继承的话，可使用如下几种方式间接实现
通过组合实现
A和B组合，作为C类的组件
通过协议实现
C类实现A和B类的协议方法
消息转发实现
forwardInvocation:方法</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB79</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>runtime 如何实现 weak 属性？</string>
		<key>topicAnswer</key>
		<string>weak 此特质表明该属性定义了一种「非拥有关系」(nonowning relationship)。为这种属性设置新值时，设置方法既不持有新值（新指向的对象），也不释放旧值（原来指向的对象）。
runtime 对注册的类，会进行内存布局，从一个粗粒度的概念上来讲，这时候会有一个 hash 表，这是一个全局表，表中是用 weak 指向的对象内存地址作为 key，用所有指向该对象的 weak 指针表作为 value。当此对象的引用计数为 0 的时候会 dealloc，假如该对象内存地址是 a，那么就会以 a 为 key，在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil。
runtime 如何实现 weak 属性具体流程大致分为 3 步：
1、初始化时：runtime 会调用 objc_initWeak 函数，初始化一个新的 weak 指针指向对象的地址。
2、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数，objc_storeWeak() 的作用是更新指针指向（指针可能原来指向着其他对象，这时候需要将该 weak 指针与旧对象解除绑定，会调用到 weak_unregister_no_lock），如果指针指向的新对象非空，则创建对应的弱引用表，将 weak 指针与新对象进行绑定，会调用到 weak_register_no_lock。在这个过程中，为了防止多线程中竞争冲突，会有一些锁的操作。
3、释放时：调用 clearDeallocating 函数，clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB80</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>OC 的消息机制</string>
		<key>topicAnswer</key>
		<string>OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）
objc_msgSend底层有3大阶段，消息发送（当前类、父类中查找）、动态方法解析、消息转发
6、runtime具体应用</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB82</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>runtime具体应用</string>
		<key>topicAnswer</key>
		<string>利用关联对象（AssociatedObject）给分类添加属性
遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）
交换方法实现（交换系统的方法）
利用消息转发机制解决方法找不到的异常问题
KVC 字典转模型</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB83</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>runtime如何通过selector找到对应的IMP地址？</string>
		<key>topicAnswer</key>
		<string>每一个类对象中都一个对象方法列表（对象方法缓存）
类方法列表是存放在类对象中isa指针指向的元类对象中（类方法缓存）。
方法列表中每个方法结构体中记录着方法的名称,方法实现,以及参数类型，其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现。
当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找。
当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB84</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>简述下Objective-C中调用方法的过程</string>
		<key>topicAnswer</key>
		<string>Objective-C是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)，整个过程介绍如下：
objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类
然后在该类中的方法列表以及其父类方法列表中寻找方法运行
如果，在最顶层的父类（一般也就NSObject）中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX
但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会，这三次拯救程序奔溃的说明见问题《什么时候会报unrecognized selector的异常》中的说明。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB85</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>load和initialize的区别</string>
		<key>topicAnswer</key>
		<string>两者都会自动调用父类的，不需要super操作，且仅会调用一次（不包括外部显示调用).
load和initialize方法都会在实例化对象之前调用，以main函数为分水岭，前者在main函数之前调用，后者在之后调用。这两个方法会被自动调用，不能手动调用它们。
load和initialize方法都不用显示的调用父类的方法而是自动调用，即使子类没有initialize方法也会调用父类的方法，而load方法则不会调用父类。
load方法通常用来进行Method Swizzle，initialize方法一般用于初始化全局变量或静态变量。
load和initialize方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB86</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>怎么理解Objective-C是动态运行时语言。</string>
		<key>topicAnswer</key>
		<string>主要是将数据类型的确定由编译时,推迟到了运行时。这个问题其实浅涉及到两个概念,运行时和多态。
简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。
多态:不同对象以自己的方式响应相同的消息的能力叫做多态。
意思就是假设生物类(life)都拥有一个相同的方法-eat;那人类属于生物,猪也属于生物,都继承了life后,实现各自的eat,但是调用是我们只需调用各自的eat方法。也就是不同的对象以自己的方式响应了相同的消 息(响应了eat这个选择器)。因此也可以说,运行时机制是多态的基础.</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB87</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>Runloop和线程的关系</string>
		<key>topicAnswer</key>
		<string>一个线程对应一个 Runloop。
主线程的默认就有了 Runloop。
子线程的 Runloop 以懒加载的形式创建。
Runloop 存储在一个全局的可变字典里，线程是 key ，Runloop 是 value。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB88</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>RunLoop的运行模式</string>
		<key>topicAnswer</key>
		<string>RunLoop的运行模式共有5种，RunLoop只会运行在一个模式下，要切换模式，就要暂停当前模式，重写启动一个运行模式
 kCFRunLoopDefaultMode, App的默认运行模式，通常主线程是在这个运行模式下运行
- UITrackingRunLoopMode, 跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）
- kCFRunLoopCommonModes, 伪模式，不是一种真正的运行模式
- UIInitializationRunLoopMode：在刚启动App时第进入的第一个Mode，启动完成后就不再使用
- GSEventReceiveRunLoopMode：接收系统内部事件，通常用不到</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB89</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>runloop内部逻辑</string>
		<key>topicAnswer</key>
		<string>通知 Observer 已经进入了 RunLoop

通知 Observer 即将处理 Timer

通知 Observer 即将处理非基于端口的输入源（即将处理 Source0）

处理那些准备好的非基于端口的输入源（处理 Source0）

如果基于端口的输入源准备就绪并等待处理，请立刻处理该事件。转到第 9 步（处理 Source1）

通知 Observer 线程即将休眠

将线程置于休眠状态，直到发生以下事件之一

事件到达基于端口的输入源（port-based input sources）(也就是 Source0)

Timer 到时间执行

外部手动唤醒

为 RunLoop 设定的时间超时

通知 Observer 线程刚被唤醒（还没处理事件）

处理待处理事件

如果是 Timer 事件，处理 Timer 并重新启动循环，跳到第 2 步

如果输入源被触发，处理该事件（文档上是 deliver the event）

如果 RunLoop 被手动唤醒但尚未超时，重新启动循环，跳到第 2 步

</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB90</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>AFNetworking 中如何运用 Runloop?</string>
		<key>topicAnswer</key>
		<string>AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：
+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}

+ (NSThread *)networkRequestThread {
    static NSThread *_networkRequestThread = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&amp;oncePredicate, ^{
        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
        [_networkRequestThread start];
    });
    return _networkRequestThread;
}
RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。
- (void)start {
    [self.lock lock];
    if ([self isCancelled]) {
        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    } else if ([self isReady]) {
        self.state = AFOperationExecutingState;
        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    }
    [self.lock unlock];
}
当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB91</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>PerformSelector 的实现原理？</string>
		<key>topicAnswer</key>
		<string>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。

当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB92</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>事件响应的过程？</string>
		<key>topicAnswer</key>
		<string>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。

当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。

_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB93</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>手势识别的过程？</string>
		<key>topicAnswer</key>
		<string>当 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。
苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer 的回调。
当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB94</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>CADispalyTimer和Timer哪个更精确</string>
		<key>topicAnswer</key>
		<string>CADisplayLink 更精确
iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。
NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。
CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB95</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>MVC、MVP、MVVM模式</string>
		<key>topicAnswer</key>
		<string>• MVC（Model、View、Controller）
MVC是比较直观的架构模式，最核心的就是通过Controller层来进行调控，首先看一下官方提供的MVC示意图：

Model和View永远不能相互通信，只能通过Controller传递

Controller可以直接与Model对话（读写调用Model），Model通过NOtification和KVO机制与Controller间接通信

Controller可以直接与View对话，通过IBoutlet直接操作View，IBoutlet直接对应View的控件（例如创建一个Button：需声明一个 IBOutlet UIButton * btn），View通过action向Controller报告时间的发生(用户点击了按钮)。Controller是View的直接数据源

优点：对于混乱的项目组织方式，有了一个明确的组织方式。通过Controller来掌控全局，同时将View展示和Model的变化分开

缺点：愈发笨重的Controller，随着业务逻辑的增加，大量的代码放进Controller，导致Controller越来越臃肿，堆积成千上万行代码，后期维护起来费时费力
• MVP（Model、View、Presenter）
MVP模式是MVC模式的一个演化版本，其中Model与MVC模式中Model层没有太大区别，主要提供数据存储功能，一般都是用来封装网络获取的json数据；View与MVC中的View层有一些差别，MVP中的View层可以是viewController、view等控件；Presenter层则是作为Model和View的中介，从Model层获取数据之后传给View。

从上图可以看出，从MVC模式中增加了Presenter层，将UIViewController中复杂的业务逻辑、网络请求等剥离出来。
优点 模型和视图完全分离，可以做到修改视图而不影响模型；更高效的使用模型，View不依赖Model，可以说VIew能做到对业务逻辑完全分离
缺点 Presenter中除了处理业务逻辑以外，还要处理View-Model两层的协调，也会导致Presenter层的臃肿
• MVVM（Model、Controller/View、ViewModel）
在MVVM中，view和ViewCOntroller联系在一起，我们把它们视为一个组件，view和ViewController都不能直接引用model，而是引用是视图模型即ViewModel。 viewModel是一个用来放置用户输入验证逻辑、视图显示逻辑、网络请求等业务逻辑的地方，这样的设计模式，会轻微增加代码量，但是会减少代码的复杂性

优点 VIew可以独立于Model的变化和修改，一个ViewModel可以绑定到不同的View上，降低耦合，增加重用

缺点 过于简单的项目不适用、大型的项目视图状态较多时构建和维护成本太大

合理的运用架构模式有利于项目、团队开发工作，但是到底选择哪个设计模式，哪种设计模式更好，就像本文开头所说，不同的设计模式，只是让不同的场景有了更多的选择方案。根据项目场景和开发需求，选择最合适的解决方案。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB96</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>关于RAC你有怎样运用到解决不同API依赖关系</string>
		<key>topicAnswer</key>
		<string>信号的依赖：使用场景是当信号A执行完才会执行信号B,和请求的依赖很类似,例如请求A请求完毕才执行请求B,我们需要注意信号A必须要执行发送完成信号,否则信号B无法执行</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB97</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>@weakify和我们宏定义的WeakSelf有什么区别？</string>
		<key>topicAnswer</key>
		<string>@weakify 可以多参数使用</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB98</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>iOS有哪些常见的设计模式？</string>
		<key>topicAnswer</key>
		<string>• 单例模式：单例保证了应用程序的生命周期内仅有一个该类的实例对象,而且易于外界访问.在ios sdk中,UIApplication, NSBundle, NSNotificationCenter, NSFileManager, NSUserDefault, NSURLCache等都是单例.
• 委托模式：委托Delegate是协议的一种,通过@protocol方式实现，常见的有tableView，textField等。
• 观察者模式：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。在iOS中,观察者模式的具体实现有两种: 通知机制(notification)和KVO机制(Key-value Observing)</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB99</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>单例会有什么弊端</string>
		<key>topicAnswer</key>
		<string>主要优点：
1、提供了对唯一实例的受控访问。
2、由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。
3、允许可变数目的实例。
主要缺点：
1、由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。
2、单例类的职责过重，在一定程度上违背了“单一职责原则”。
3、滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB100</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>编程中的六大设计原则</string>
		<key>topicAnswer</key>
		<string>1.单一职责原则
通俗地讲就是一个类只做一件事
CALayer：动画和视图的显示。
UIView：只负责事件传递、事件响应。
2.开闭原则
对修改关闭，对扩展开放。 要考虑到后续的扩展性，而不是在原有的基础上来回修改
3.接口隔离原则
使用多个专门的协议、而不是一个庞大臃肿的协议，如 UITableviewDelegate + UITableViewDataSource
4.依赖倒置原则
抽象不应该依赖于具体实现、具体实现可以依赖于抽象。 调用接口感觉不到内部是如何操作的
5.里氏替换原则
父类可以被子类无缝替换，且原有的功能不受任何影响 如：KVO
6.迪米特法则
一个对象应当对其他对象尽可能少的了解，实现高聚合、低耦合</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB101</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>组件化有什么好处</string>
		<key>topicAnswer</key>
		<string>a)业务分层、解耦，使代码变得可维护；
b)有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；
c)便于各业务功能拆分、抽离，实现真正的功能复用；
d)业务隔离，跨团队开发代码控制和版本风险控制的实现；
e)模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力；
f)在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App）</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB102</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>你是如何组件化解耦的？</string>
		<key>topicAnswer</key>
		<string>分层
基础功能组件：按功能分库，不涉及产品业务需求，跟库Library类似，通过良好的接口拱上层业务组件调用；不写入产品定制逻辑，通过扩展接口完成定制；
基础UI组件：各个业务模块依赖使用，但需要保持好定制扩展的设计
业务组件：业务功能间相对独立，相互间没有Model共享的依赖；业务之间的页面调用只能通过UIBus进行跳转；业务之间的逻辑Action调用只能通过服务提供；
中间件：target-action，url-block，protocol-class</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB103</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>为什么CTMediator方案优于基于Router的方案</string>
		<key>topicAnswer</key>
		<string>Router的缺点：
在组件化的实施过程中，注册URL并不是充分必要条件。组件是不需要向组件管理器注册URL的，注册了URL之后，会造成不必要的内存常驻。注册URL的目的其实是一个服务发现的过程，在iOS领域中，服务发现的方式是不需要通过主动注册的，使用runtime就可以了。另外，注册部分的代码的维护是一个相对麻烦的事情，每一次支持新调用时，都要去维护一次注册列表。如果有调用被弃用了，是经常会忘记删项目的。runtime由于不存在注册过程，那就也不会产生维护的操作，维护成本就降低了。 由于通过runtime做到了服务的自动发现，拓展调用接口的任务就仅在于各自的模块，任何一次新接口添加，新业务添加，都不必去主工程做操作，十分透明。
在iOS领域里，一定是组件化的中间件为openURL提供服务，而不是openURL方式为组件化提供服务。如果在给App实施组件化方案的过程中是基于openURL的方案的话，有一个致命缺陷：非常规对象(不能被字符串化到URL中的对象，例如UIImage)无法参与本地组件间调度。 在本地调用中使用URL的方式其实是不必要的，如果业务工程师在本地间调度时需要给出URL，那么就不可避免要提供params，在调用时要提供哪些params是业务工程师很容易懵逼的地方。
为了支持传递非常规参数，蘑菇街的方案采用了protocol，这个会侵入业务。由于业务中的某个对象需要被调用，因此必须要符合某个可被调用的protocol，然而这个protocol又不存在于当前业务领域，于是当前业务就不得不依赖public Protocol。这对于将来的业务迁移是有非常大的影响的。
CTMediator的优点：
调用时，区分了本地应用调用和远程应用调用。本地应用调用为远程应用调用提供服务。
组件仅通过Action暴露可调用接口，模块与模块之间的接口被固化在了Target-Action这一层，避免了实施组件化的改造过程中，对Business的侵入，同时也提高了组件化接口的可维护性。

方便传递各种类型的参数。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB104</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>基于CTMediator的组件化方案，有哪些核心组成？</string>
		<key>topicAnswer</key>
		<string>CTMediator中间件：集成就可以了
模块Target_%@：模块的实现及提供对外的方法调用Action_methodName，需要传参数时，都统一以NSDictionary*的形式传入。
CTMediator+%@扩展：扩展里声明了模块业务的对外接口，参数明确，这样外部调用者可以很容易理解如何调用接口。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB105</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>LLDB常用的调试命令</string>
		<key>topicAnswer</key>
		<string>po：print object的缩写，表示显示对象的文本描述，如果对象不存在则打印nil。
p：可以用来打印基本数据类型。
call：执行一段代码 如：call NSLog(@&quot;%@&quot;, @&quot;yang&quot;)
expr：动态执行指定表达式
bt：打印当前线程堆栈信息 （bt all 打印所有线程堆栈信息）
image：常用来寻找栈地址对应代码位置 如：image lookup --address 0xxxx</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB106</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>断点调试</string>
		<key>topicAnswer</key>
		<string>• 条件断点
打上断点之后，对断点进行编辑，设置相应过滤条件。下面简单的介绍一下条件设置：
Condition：返回一个布尔值，当布尔值为真触发断点，一般里面我们可以写一个表达式。
Ignore：忽略前N次断点，到N+1次再触发断点。
Action：断点触发事件，分为六种：
AppleScript：执行脚本。
Capture GPU Frame：用于OpenGL ES调试，捕获断点处GPU当前绘制帧。
Debugger Command：和控制台中输入LLDB调试命令一致。
Log Message：输出自定义格式信息至控制台。
Shell Command：接收命令文件及相应参数列表，Shell Command是异步执行的，只有勾选“Wait until done”才会等待Shell命令执行完在执行调试。
Sound：断点触发时播放声音。
Options(Automatically continue after evaluating actions选项)：选中后，表示断点不会终止程序的运行。
• 异常断点
异常断点可以快速定位不满足特定条件的异常，比如常见的数组越界，这时候很难通过异常信息定位到错误所在位置。这个时候异常断点就可以发挥作用了。
Exception：可以选择抛出异常对象类型：OC或C++。
Break：选择断点接收的抛出异常来源是Throw还是Catch语句。
• 符号断点
符号断点的创建方式和异常断点一样一样的，在符号断点中可以指定要中断执行的方法：
Symbol:[类名 方法名]可以执行到指定类的指定方法中开始断点。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB107</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>iOS 常见的崩溃类型有哪些？</string>
		<key>topicAnswer</key>
		<string>unrecognized selector crash
KVO crash
NSNotification crash
NSTimer crash
Container crash
NSString crash
Bad Access crash （野指针）
UI not on Main Thread Crash</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB108</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>造成tableView卡顿的原因有哪些？</string>
		<key>topicAnswer</key>
		<string>1.最常用的就是cell的重用， 注册重用标识符
如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell
如果有很多数据的时候，就会堆积很多cell。
如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell
2.避免cell的重新布局
cell的布局填充等操作 比较耗时，一般创建时就布局好
如 可以将cell单独放到一个自定义类，初始化时就布局好
3.提前计算并缓存cell的属性及内容
当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度
而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell
4.减少cell中控件的数量
尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，
不适用的可以先隐藏
5.不要使用ClearColor，无背景色，透明度也不要设置为0
渲染耗时比较长
6.使用局部更新
如果只是更新某组的话，使用reloadSection进行局部更
7.加载网络数据，下载图片，使用异步加载，并缓存
8.少使用addView 给cell动态添加view
9.按需加载cell，cell滚动很快时，只加载范围内的cell
10.不要实现无用的代理方法，tableView只遵守两个协议
11.缓存行高：estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可
12.不要做多余的绘制工作。在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。
13.预渲染图像。当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕；
14.使用正确的数据结构来存储数据。

</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB109</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>.如何提升 tableview 的流畅度？https://www.jianshu.com/p/cff0d1b3c915 离屏渲染问题。</string>
		<key>topicAnswer</key>
		<string>本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。
CPU：对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制
GPU：纹理的渲染
卡顿优化在 CPU 层面
尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView
不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改
尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性
Autolayout 会比直接设置 frame 消耗更多的 CPU 资源
图片的 size 最好刚好跟 UIImageView 的 size 保持一致
控制一下线程的最大并发数量
尽量把耗时的操作放到子线程
文本处理（尺寸计算、绘制）
图片处理（解码、绘制）
卡顿优化在 GPU层面
尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示
GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸
尽量减少视图数量和层次
减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES
尽量避免出现离屏渲染
iOS 保持界面流畅的技巧
1.预排版，提前计算
在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。
尽量少用 UILabel，可以使用 CALayer 。避免使用 AutoLayout 的自动布局技术，采取纯代码的方式
2.预渲染，提前绘制
例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了
避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。
3.异步绘制
4.全局并发线程
5.高效的图片异步加载</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB110</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>APP启动时间应从哪些方面优化？</string>
		<key>topicAnswer</key>
		<string>App启动时间可以通过xcode提供的工具来度量，在Xcode的Product-&gt;Scheme--&gt;Edit Scheme-&gt;Run-&gt;Auguments中，将环境变量DYLD_PRINT_STATISTICS设为YES，优化需以下方面入手

dylib loading time（动态库加载时间）
核心思想是减少dylibs的引用
合并现有的dylibs（最好是6个以内）
使用静态库
rebase/binding time
核心思想是减少DATA块内的指针
减少Object C元数据量，减少Objc类数量，减少实例变量和函数（与面向对象设计思想冲突）
减少c++虚函数
多使用Swift结构体（推荐使用swift）
ObjC setup time
核心思想同上，这部分内容基本上在上一阶段优化过后就不会太过耗时
initializer time
使用initialize替代load方法
减少使用c/c++的attribute((constructor))；推荐使用dispatch_once() pthread_once() std:once()等方法
推荐使用swift
不要在初始化中调用dlopen()方法，因为加载过程是单线程，无锁，如果调用dlopen则会变成多线程，会开启锁的消耗，同时有可能死锁
不要在初始化中创建线程</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB111</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>如何降低APP包的大小</string>
		<key>topicAnswer</key>
		<string>降低包大小需要从两方面着手
可执行文件
编译器优化：Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default 设置为 YES，去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions 利用 AppCode 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code
编写LLVM插件检测出重复代码、未被调用的代码
资源（图片、音频、视频 等）
优化的方式可以对资源进行无损的压缩
去除没有用到的资源： https://github.com/tinymind/LSUnusedResources</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB112</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>如何检测离屏渲染与优化</string>
		<key>topicAnswer</key>
		<string>检测，通过勾选Xcode的Debug-&gt;View Debugging--&gt;Rendering-&gt;Run-&gt;Color Offscreen-Rendered Yellow项。
优化，如阴影，在绘制时添加阴影的路径</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB113</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>怎么检测图层混合</string>
		<key>topicAnswer</key>
		<string>1、模拟器debug中color blended layers红色区域表示图层发生了混合

2、Instrument-选中Core Animation-勾选Color Blended Layers

• 避免图层混合：
确保控件的opaque属性设置为true，确保backgroundColor和父视图颜色一致且不透明
如无特殊需要，不要设置低于1的alpha值
确保UIImage没有alpha通道
UILabel图层混合解决方法：
iOS8以后设置背景色为非透明色并且设置label.layer.masksToBounds=YES让label只会渲染她的实际size区域，就能解决UILabel的图层混合问题
iOS8 之前只要设置背景色为非透明的就行
为什么设置了背景色但是在iOS8上仍然出现了图层混合呢？
UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变。在背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，设置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪 图层混合问题解决了</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB114</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>日常如何检查内存泄露？</string>
		<key>topicAnswer</key>
		<string>目前我知道的方式有以下几种
Memory Leaks
Alloctions
Analyse
Debug Memory Graph
MLeaksFinde
泄露的内存主要有以下两种：
Laek Memory 这种是忘记 Release 操作所泄露的内存。
Abandon Memory 这种是循环引用，无法释放掉的内存。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB115</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>SDWebImage加载图片过程</string>
		<key>topicAnswer</key>
		<string>0、首先显示占位图
1、在webimagecache（卡斯）中寻找图片对应的缓存，它是以url为数据索引先在内存中查找是否有缓存；
2、如果没有缓存，就通过md5处理过的key来在磁盘中查找对应的数据，如果找到就会把磁盘中的数据加到内存中，并显示出来；
3、如果内存和磁盘中都没有找到，就会向远程服务器发送请求，开始下载图片；
4、下载完的图片加入缓存中，并写入到磁盘中；
5、整个获取图片的过程是在子线程中进行，在主线程中显示。
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB116</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>AFNetworking 底层原理分析</string>
		<key>topicAnswer</key>
		<string>AFNetworking是封装的NSURLSession的网络请求，由五个模块组成：分别由NSURLSession,Security,Reachability,Serialization,UIKit五部分组成
NSURLSession：网络通信模块（核心模块） 对应 AFNetworking中的 AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager,AFHTTPSessionManager是继承于AFURLSessionmanager的
Security：网络通讯安全策略模块  对应 AFSecurityPolicy
Reachability：网络状态监听模块 对应AFNetworkReachabilityManager
Seriaalization：网络通信信息序列化、反序列化模块 对应 AFURLResponseSerialization</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB117</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>数据结构的存储一般常用的有几种？各有什么特点？</string>
		<key>topicAnswer</key>
		<string>数据结构的存储一般常用的有两种 顺序存储结构 和 链式存储结构

顺序存储结构:

比如，数组，1-2-3-4-5-6-7-8-9-10，存储是按顺序的。再比如栈和队列等

链式存储结构:

比如，数组，1-2-3-4-5-6-7-8-9-10，链式存储就不一样了 1(地址)-2(地址)-7(地址)-4(地址)-5(地址)-9(地址)-8(地址)-3(地址)-6(地址)-10(地址)。每个数字后面跟着一个地址 而且存储形式不再是顺序
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB118</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>集合结构 线性结构 树形结构 图形结构</string>
		<key>topicAnswer</key>
		<string>集合结构
一个集合，就是一个圆圈中有很多个元素，元素与元素之间没有任何关系 这个很简单

线性结构
一个条线上站着很多个人。 这条线不一定是直的。也可以是弯的。也可以是值的 相当于一条线被分成了好几段的样子 （发挥你的想象力）。 线性结构是一对一的关系

树形结构
做开发的肯定或多或少的知道xml 解析 树形结构跟他非常类似。也可以想象成一个金字塔。树形结构是一对多的关系

图形结构
这个就比较复杂了。他呢 无穷。无边 无向（没有方向）图形机构 你可以理解为多对多 类似于我们人的交集关系</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB119</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>单向链表 双向链表 循环链表</string>
		<key>topicAnswer</key>
		<string>单向链表 
A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H. 这就是单向链表 H 是头 A 是尾 像一个只有一个头的火车一样 只能一个头拉着跑 
双向链表 
循环链表
循环链表是与单向链表一样，是一种链式的存储结构，所不同的是，循环链表的最 后一个结点的指针是指向该循环链表的第一个结点或者表头结点，从而构成一个环形的链。发挥想象力 A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H-&gt;A. 绕成一个圈。就像蛇吃自己的这就是循环 不需要去死记硬背哪些理论知识。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB120</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>数组和链表的区别</string>
		<key>topicAnswer</key>
		<string>数组
数组元素在内存上连续存放，可以通过下标查找元素；插入、删除需要移动大量元素，比较适用于元素很少变化的情况

链表
链表中的元素在内存中不是顺序存储的，查找慢，插入、删除只需要对元素指针重新赋值，效率高</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB121</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>堆、栈和队列</string>
		<key>topicAnswer</key>
		<string>堆
堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：
1）堆中某个节点的值总是不大于或不小于其父节点的值；
2）堆总是一棵完全二叉树。
堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆，在一个摆放好元素的最小堆中，父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。
堆常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。
栈
栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈的特殊之处在于它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。

栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 LIFO（Last In First Out）结构。也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放进去比较晚的物体）。
堆栈中定义了一些操作。两个最重要的是PUSH和POP。PUSH操作在堆栈的顶部加入一个元素。POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一
栈的应用—递归
队列
队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。它是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。

队列是一种先进先出的数据结构，又称为先进先出的线性表，简称 FIFO（First In First Out）结构。也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来。
</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB122</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>输入一棵二叉树的根结点，求该树的深度？</string>
		<key>topicAnswer</key>
		<string>二叉树的结点定义如下：
struct BinaryTreeNode
{
	int m_nValue ；
	BinaryTreeNode* m_pLeft;
	BinarvTreeNode* m_pRight ；
}
如果一棵树只有一个结点，它的深度为1。
如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。
如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。
int TreeDepth(TreeNode* pRoot)
{
    if(pRoot == nullptr)
        return 0;
    int left = TreeDepth(pRoot-&gt;left);
    int right = TreeDepth(pRoot-&gt;right);

    return (left&gt;right) ? (left+1) : (right+1);
}</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB123</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>输入一课二叉树的根结点，判断该树是不是平衡二叉树？</string>
		<key>topicAnswer</key>
		<string>重复遍历结点
先求出根结点的左右子树的深度，然后判断它们的深度相差不超过1，如果否，则不是一棵二叉树；如果是，再用同样的方法分别判断左子树和右子树是否为平衡二叉树，如果都是，则这就是一棵平衡二叉树。
遍历一遍结点
遍历结点的同时记录下该结点的深度，避免重复访问。
方法一：
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
};
 
int TreeDepth(TreeNode* pRoot){
    if(pRoot==NULL)
        return 0;
    int left=TreeDepth(pRoot-&gt;left);
    int right=TreeDepth(pRoot-&gt;right);
    return left&gt;right?(left+1):(right+1);
}
 
bool IsBalanced(TreeNode* pRoot){
    if(pRoot==NULL)
        return true;
    int left=TreeDepth(pRoot-&gt;left);
    int right=TreeDepth(pRoot-&gt;right);
    int diff=left-right;
    if(diff&gt;1 || diff&lt;-1)
        return false;
    return IsBalanced(pRoot-&gt;left) &amp;&amp; IsBalanced(pRoot-&gt;right);
}

方法二：
bool IsBalanced_1(TreeNode* pRoot,int&amp; depth){
    if(pRoot==NULL){
        depth=0;
        return true;
    }
    int left,right;
    int diff;
    if(IsBalanced_1(pRoot-&gt;left,left) &amp;&amp; IsBalanced_1(pRoot-&gt;right,right)){
        diff=left-right;
        if(diff&lt;=1 || diff&gt;=-1){
            depth=left&gt;right?left+1:right+1;
            return true;
        }
    }
    return false;
}
 
bool IsBalancedTree(TreeNode* pRoot){
    int depth=0;
    return IsBalanced_1(pRoot,depth);
} </string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB124</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>时间复杂度</string>
		<key>topicAnswer</key>
		<string> 时间频度:
一个算法执行所耗费的时间,从理论上是不能算出来的,必须上机运行测试才能知道.但我们不可能也没有必要对每个算法都上机测试,只需知道哪个算法花费的时间多,哪个算法花费的时间少就可以了.并且一个算法花费的时间与算法中语句的执行次数成正比例,哪个算法中语句执行次数多,它花费时间就多.一个算法中的语句执行次数称为语句频度或时间频度.记为T(n).

时间复杂度:
一般情况下,算法中基本操作重复执行的次数是问题规模n的某个函数,用T(n)表示,若有某个辅助函数f(n),使得当n趋近于无穷大时,T（n)/f(n)的极限值为不等于零的常数,则称f(n)是T(n)的同数量级函数.记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度,简称时间复杂度.

在各种不同算法中,若算法中语句执行次数为一个常数,则时间复杂度为O(1),另外,在时间频度不相同时,时间复杂度有可能相同,如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同,但时间复杂度相同,都为O(n2).

按数量级递增排列,常见的时间复杂度有：

O(1)称为常量级，算法的时间复杂度是一个常数。

O(n)称为线性级，时间复杂度是数据量n的线性函数。

O(n²)称为平方级，与数据量n的二次多项式函数属于同一数量级。

O(n³)称为立方级，是n的三次多项式函数。

O(logn)称为对数级，是n的对数函数。

O(nlogn)称为介于线性级和平方级之间的一种数量级

O(2ⁿ)称为指数级，与数据量n的指数函数是一个数量级。

O(n!)称为阶乘级，与数据量n的阶乘是一个数量级。

它们之间的关系是： O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)，随着问题规模n的不断增大,上述时间复杂度不断增大,算法的执行效率越低.

</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB125</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>空间复杂度</string>
		<key>topicAnswer</key>
		<string> 评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。不包括算法程序代码和所处理的数据本身所占空间部分。通常用所使用额外空间的字节数表示。其算法比较简单，记为S(n)=O(f(n))，其中，n表示问题规模。</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB126</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>常用的排序算法</string>
		<key>topicAnswer</key>
		<string> 选择排序、冒泡排序、插入排序三种排序算法可以总结为如下：
都将数组分为已排序部分和未排序部分。
选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。
冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。
插入排序将已排序部分定义在左端，将未排序部分元的第一个元素插入到已排序部分合适的位置。
/** 
 *	【选择排序】：最值出现在起始端
 *	
 *	第1趟：在n个数中找到最小(大)数与第一个数交换位置
 *	第2趟：在剩下n-1个数中找到最小(大)数与第二个数交换位置
 *	重复这样的操作...依次与第三个、第四个...数交换位置
 *	第n-1趟，最终可实现数据的升序（降序）排列。
 *
 */
void selectSort(int *arr, int length) {
    for (int i = 0; i &lt; length - 1; i++) { //趟数
        for (int j = i + 1; j &lt; length; j++) { //比较次数
            if (arr[i] &gt; arr[j]) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
}
 
/** 
 *	【冒泡排序】：相邻元素两两比较，比较完一趟，最值出现在末尾
 *	第1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n个元素位置
 *	第2趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n-1个元素位置
 *	 ……   ……
 *	第n-1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第2个元素位置	
 */
void bublleSort(int *arr, int length) {
    for(int i = 0; i &lt; length - 1; i++) { //趟数
        for(int j = 0; j &lt; length - i - 1; j++) { //比较次数
            if(arr[j] &gt; arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        } 
    }
}
 
/**
 *	折半查找：优化查找时间（不用遍历全部数据）
 *
 *	折半查找的原理：
 *   1&gt; 数组必须是有序的
 *   2&gt; 必须已知min和max（知道范围）
 *   3&gt; 动态计算mid的值，取出mid对应的值进行比较
 *   4&gt; 如果mid对应的值大于要查找的值，那么max要变小为mid-1
 *   5&gt; 如果mid对应的值小于要查找的值，那么min要变大为mid+1
 *
 */ 
 
// 已知一个有序数组, 和一个key, 要求从数组中找到key对应的索引位置 
int findKey(int *arr, int length, int key) {
    int min = 0, max = length - 1, mid;
    while (min &lt;= max) {
        mid = (min + max) / 2; //计算中间值
        if (key &gt; arr[mid]) {
            min = mid + 1;
        } else if (key &lt; arr[mid]) {
            max = mid - 1;
        } else {
            return mid;
        }
    }
    return -1;
}</string>
	</dict>
	<dict>
		<key>topicID</key>
		<string>B3D13263-0800-4266-9D3B-0D91D5554BB127</string>
		<key>topicType</key>
		<string>Swift</string>
		<key>topicTitle</key>
		<string>字符串反转</string>
		<key>topicAnswer</key>
		<string> void char_reverse (char *cha) {

    // 定义头部指针
    char *begin = cha;
    // 定义尾部指针
    char *end = cha + strlen(cha) -1;
    while (begin &lt; end) {
        char temp = *begin;
        *(begin++) = *end;
        *(end--) = temp;
    }
}</string>
	</dict>
</array>
</plist>
